
# Тестовое задание на вывод условных товаров из выбранного API

Ссылка на задание: https://docs.google.com/document/d/1-NyWe49nKCQf4opWrDwV5YLWzR9eCEK_/edit

Ссылка на выбранное API: https://jsonplaceholder.typicode.com/
Api может зависать, это нормально.
Были использованы эндпоинты:
1) https://jsonplaceholder.typicode.com/albums/1/photos для вывода списков товаров
2) https://jsonplaceholder.typicode.com/photos/1 для получения информации об одном товаре

При выполнении задания я писал код так, будто это приложение -- заготовка для настоящего приложения, которое можно будет использовать для решения конкретной бизнес-задачи, из-за чего некоторый фукционал работает не так, как должно быть по заданию. Подробнее это будет расписано после описания структуры проекта.

Инструкция для развёртывания проекта описана в самом низу

## Структура проекта

Для приложения была использована архитектура FSD: https://feature-sliced.design/docs/get-started/overview
```
- public/                     // Папка для статических файлов, доступных на сервере (например, изображений)
- src/                        // Главная папка с исходным кодом приложения
  - app/                        // Входная точка приложения и основные настройки
    - layouts/                    // Компоненты для макетов страниц 
    - main.tsx                    // Главный файл, точка входа в приложение. Здесь настроена навигация
    - vite-env.d.ts               // Файл, без которого не будут работать переменные окружения в Vite
  - entities/                   // Сущности (базовые строительные блоки приложения)
    - ProductCard/                // Карточка товара
  - features/                   // Фичи (комплексные модули с бизнес-логикой)
    - ProductForm/                // Форма для работы с товарами (создание, редактирование)
  - pages/                      // Страницы приложения
    - ErrorPage/                  // Страница для вывода ошибки при навигации
    - MainPage/                   // Главная страница приложения (про неё не сказано в задании, так что она по сути является просто ссылкой на страницу со списком товаров )
    - ProductCreate/              // Страница создания нового товара
    - ProductEdit/                // Страница редактирования товара
    - ProductInfo/                // Страница с детальной информацией о товаре
    - ProductsPage/               // Страница со списком товаров
  - shared/                     // Общие модули и ресурсы, используемые в приложении
    - api/                        // Логика работы с запросами к API
    - hooks/                      // Пользовательские хуки
    - store/                      // Redux-хранилище и редьюсеры
    - styles/                     // Общие стили приложения
    - types/                      // Общие типы и интерфейсы TypeScript
    - ui/                         // Компоненты пользовательского интерфейса, такие как кнопки
- .env.local                  // Локальные переменные окружения (нужно создать вручную)
- .gitignore                  // Файлы и папки, игнорируемые Git
- eslint.config.js            // Конфигурация для линтера ESLint
- index.html                  // Основной HTML-файл, используемый Vite
- package.json                // Список зависимостей и скриптов проекта
- README.md                   // Документация проекта
- tsconfig.app.json           // Конфигурация TypeScript для приложения
- tsconfig.json               // Общая конфигурация TypeScript
- tsconfig.node.json          // Конфигурация TypeScript для серверных/Node.js файлов
- vite.config.ts              // Конфигурация Vite
- yarn.lock                   // Фиксация версий зависимостей для Yarn
```

## Отличия от задания

Подразумевая, что это приложение в будущем может работать с настоящим API, некоторый функционал было логичнее всего реализовать не так, как требовалось в задании. Например, в данном приложении каталог товаров загружает данные с сервера каждый раз при отрисовке компонента, что нормально для настоящего (не тестового) сайта. Однако при такой реализации это порождает несколько проблем.

Среди них — невозможность добавить товар в избранное со страницы с детальной информацией о товаре. При нормальных условиях после нажатия на кнопку добавления в избранное отправляется запрос на сервер, приводящий к изменению данных в БД. Если пользователь перейдёт на страницу со всеми товарами, то снова произойдёт запрос на сервер для их получения, и на этот раз товар будет считаться избранным. В данном же приложении возможности изменить состояние БД нет, поэтому товар не будет считаться избранным при возврате на страницу со всеми товарами. То же самое касается удаления, создания и редактирования товаров.

Однако код написан так, что в него можно легко вставить запрос к потенциальному настоящему API для изменения состояния БД, что тут же решит вышеуказанную проблему. Конечно, можно было бы реализовать сохранение избранных товаров в `localStorage`, но для этого нужно чёткое понимание предметной области, чтобы не писать код, который может оказаться ненужным. Например, потенциальному заказчику может быть важно, чтобы избранные товары хранились именно в БД. А уточнить это невозможно, так как нет реального заказчика.

Также можно было бы предусмотреть логику, чтобы не запрашивать те данные, которые уже есть, сохраняя изменения в рамках сессии. Но, опять же, эта реализация может быть удалена в будущем, если бы это был настоящий проект.

Ниже я детально расписал всё, что нужно было бы доработать, если бы это был настоящий проект, а не тестовый.

## Что нужно точно изменить, если бы это был настоящий проект

1) Разделить функционал Администратора и Пользователя. 
Обычный пользователь не должен иметь возможности удалять, редактировать и добавлять товары. Этот функционал должен быть вынесен в панель администратора, которую можно легко реализовать с помощью react-admin. Конечно, можно оставить функционал на своём месте, но тогда придётся прописывать много однотипной логики для разделения ролей в каждом компоненте, где она присутствует. Это сделает код трудно поддерживаемым.
2) src/store/reducers/:
	2.1) getProduct: 
	Можно избавиться от необходимости поиска товара в списке уже загруженных, если есть возможность получать его с сервера. В текущей реализации это сделано так, чтобы избранное сохранялось хотя бы при переходе с ProductsPage на ProductInfo.
	
	2.2) likeProduct, deleteProduct, saveProduct, editProduct: 
Эти действия должны быть реализованы с помощью createAsyncThunk, чтобы удобнее обрабатывать соответствующие запросы. Также нужно прописать сами запросы, потому что сейчас они не были нужны.
	
	2.3) Можно вынести все Thunk-функции в отдельный файл, например, productsThunks.ts, чтобы не загромождать редьюсер. Пока что в этом нет большой необходимости.
	
3) src/features/ProductForm.
В идеале здесь нужно сделать возможность загрузки изображения не ссылкой, а файлом, что можно было бы легко сделать с помощью того же react-admin.

4) src/pages/MainPage.
Для коммерческого приложения нужна более привлекательная главная страница, чтобы пользователи хотели остаться на сайте.

### Также можно улучшить следующие моменты

1) src/shared/api.
Если приложению нужна будет авторизация, здесь можно добавить перехватчики для добавления JWT токена и ошибки, связанной с его устареванием. Также здесь можно создать dataProvider, если бэкенд поддерживает REST или работает по похожим правилам. Это позволит унифицировать логику работы с API и сократить дублирование кода.

2) Можно вынести функционал вроде handleLike и handleDelete в отдельный хук, чтобы код меньше повторялся. Но с учётом пункта 1, обработку удаления в идеале нужно вынести в другой раздел сайта, а также, возможно, стоит добавить функционал добаления товара в корзину. После этого данное решение выглядит гораздо более целесообразным, но пока что досточно и такого варианта

3) Конечно, сайт можно сделать красивее и оптимизировать. Однако не всегда это оправдано, особенно на этапе тестового задания.

## Развёртывание проекта

Ссылка на деплой: https://products-test-task.vercel.app/

Для локального запуска веб-приложение нужно выполнить следующие инструкции:

### 1. Клонирование репозитория Склонируйте репозиторий на свой компьютер, используя Git: 

```bash
git clone https://github.com/Krit2124/products-test-task.git
```

---

### 2. Перейдите в директорию проекта 

```bash 
cd products-test-task
```

---

### 3. Убедитесь, что у вас установлены следующие зависимости

- [Node.js](https://nodejs.org/) (рекомендуется версия **16.x** или выше)
- [npm](https://www.npmjs.com/) или [yarn](https://yarnpkg.com/) для управления пакетами

Проверьте версии Node.js и npm, выполнив:
```bash
node -v
npm -v
```

---

### 4. Установка зависимостей

Для установки всех необходимых пакетов выполните:

```bash
npm install
```

Или, если вы используете Yarn:

```bash
yarn
```

---

### 5. Запуск приложения в режиме разработки

После установки зависимостей запустите проект локально:

```bash
npm run dev
```

Или с использованием Yarn:

```bash
yarn dev
```

После запуска вы увидите в консоли URL-адрес. Обычно это:

```
  Local:   http://localhost:5173/
```

Перейдите по указанному адресу в вашем браузере.

---

### 6. Сборка приложения для продакшена

Для сборки оптимизированной версии приложения выполните:

```bash
npm run build
```

Или с использованием Yarn:

```bash
yarn build
```

Это создаст папку `dist`, содержащую готовую к развертыванию версию приложения.

---

### 7. Предпросмотр продакшн-сборки (опционально)

Чтобы запустить предварительный просмотр продакшн-версии:

```bash
npm run preview
```

Или с использованием Yarn:

```bash
yarn preview
```

---

## 🛠 Настройка окружения

Создайте файл `.env.local` в корне проекта и добавьте туда переменные окружения. Для данного проекта нужна только одна переменная хранящая API, к которому будет обращаться приложение за данными. Хоть это и тестовое API, не требующее секретности, но если бы оно было настоящим, то его нужно было бы хранить так:

```
VITE_API_URL = https://jsonplaceholder.typicode.com/
```